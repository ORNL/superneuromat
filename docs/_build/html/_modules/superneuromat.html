

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>superneuromat &mdash; SuperNeuroMAT 2.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=51b770b3"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            SuperNeuroMAT
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">SuperNeuroMAT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">superneuromat</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for superneuromat</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.sparse</span><span class="w"> </span><span class="kn">import</span> <span class="n">csc_array</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

<span class="c1"># import ctypes</span>
<span class="c1"># import os</span>
<span class="c1"># import multiprocessing as mp</span>
<span class="c1"># import subprocess</span>
<span class="c1"># import mmap</span>


<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">TODO:</span>

<span class="sd">1. create_neurons() </span>
<span class="sd">2. create_synapses()</span>
<span class="sd">3. create_neurons_from_file()</span>
<span class="sd">4. create_synapses_from_file() </span>
<span class="sd">5. Tutorials: one neuron, two neurons </span>

<span class="sd">&quot;&quot;&quot;</span>



<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">FEATURE REQUESTS: </span>

<span class="sd">1. Visualize spike raster</span>
<span class="sd">2. Monitor STDP synapses</span>

<span class="sd">&quot;&quot;&quot;</span>




<div class="viewcode-block" id="SNN">
<a class="viewcode-back" href="../superneuromat.html#superneuromat.SNN">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SNN</span><span class="p">:</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot; Defines a spiking neural network (SNN) with neurons and synapses</span>

<span class="sd">	Attributes:</span>
<span class="sd">		num_neurons (int): Number of neurons in the SNN</span>
<span class="sd">		neuron_thresholds (list): List of neuron thresholds</span>
<span class="sd">		neuron_leaks (list): List of neuron leaks, defined as the amount by which the internal states of the neurons are pushed towards the neurons&#39; reset states</span>
<span class="sd">		neuron_reset_states (list): List of neuron reset states</span>
<span class="sd">		neuron_refractory_periods (list): List of neuron refractory periods</span>

<span class="sd">		num_synapses (int): Number of synapses in the SNN</span>
<span class="sd">		pre_synaptic_neuron_ids (list): List of pre-synaptic neuron IDs</span>
<span class="sd">		post_synaptic_neuron_ids (list): List of post-synaptic neuron IDs</span>
<span class="sd">		synaptic_weights (list): List of synaptic weights</span>
<span class="sd">		synaptic_delays (list): List of synaptic delays</span>
<span class="sd">		enable_stdp (list): List of Boolean values denoting whether STDP learning is enabled on each synapse</span>
<span class="sd">		</span>
<span class="sd">		input_spikes (dict): Dictionary of input spikes indexed by time</span>
<span class="sd">		spike_train (list): List of spike trains for each time step</span>
<span class="sd">		</span>
<span class="sd">		stdp (bool): Boolean parameter that denotes whether STDP learning has been enabled in the SNN</span>
<span class="sd">		stdp_time_steps (int): Number of time steps over which STDP updates are made</span>
<span class="sd">		stdp_Apos (list): List of STDP parameters per time step for excitatory update of weights</span>
<span class="sd">		stdp_Aneg (list): List of STDP parameters per time step for inhibitory update of weights</span>


<span class="sd">	Methods:</span>
<span class="sd">		create_neuron: Creates a neuron in the SNN</span>
<span class="sd">		create_synapse: Creates a synapse in the SNN</span>
<span class="sd">		add_spike: Add an external spike at a particular time step for a given neuron with a given value</span>
<span class="sd">		stdp_setup: Setup the STDP parameters</span>
<span class="sd">		setup: Setup the SNN and prepare for simulation</span>
<span class="sd">		simulate: Simulate the SNN for a given number of time steps</span>
<span class="sd">		print_spike_train: Print the spike train</span>
<span class="sd">		</span>

<span class="sd">	CAUTION:</span>
<span class="sd">		1. Delay is implemented by adding a chain of proxy neurons. A delay of 10 between neuron A and neuron B would add 9 proxy neurons between A and B.</span>
<span class="sd">		2. Leak brings the internal state of the neuron back to the reset state. The leak value is the amount by which the internal state of the neuron is pushed towards its reset state.</span>
<span class="sd">		3. Deletion of neurons is not permitted</span>
<span class="sd">		4. Multiple synapses from one neuron to any another neuron are not permitted</span>
<span class="sd">		5. Input spikes can have a value</span>
<span class="sd">		6. All neurons are monitored by default</span>

<span class="sd">	&quot;&quot;&quot;</span>


	<span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="n">num_mpi_ranks</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot; Initialize the SNN</span>

<span class="sd">		Args:</span>
<span class="sd">			backend (string): Backend is either &#39;cpu&#39; or &#39;frontier&#39;</span>

<span class="sd">		Raises: </span>
<span class="sd">			TypeError if:</span>
<span class="sd">				1. backend is not a string</span>

<span class="sd">			ValueError if: </span>
<span class="sd">				2. backend is not one of the following values: cpu, frontier</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="c1"># Type errors</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">backend</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;backend must be either &#39;cpu&#39;, or &#39;frontier&#39;&quot;</span><span class="p">)</span>

		<span class="c1"># Value errors</span>
		<span class="k">if</span> <span class="n">backend</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="s2">&quot;frontier&quot;</span><span class="p">}:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;backend must be either &#39;cpu&#39;, or &#39;frontier&#39;&quot;</span><span class="p">)</span>


		<span class="c1"># Neuron parameters</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">neuron_thresholds</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">neuron_leaks</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">neuron_reset_states</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">neuron_refractory_periods</span> <span class="o">=</span> <span class="p">[]</span>

		<span class="c1"># Synapse parameters</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">num_synapses</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">pre_synaptic_neuron_ids</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">post_synaptic_neuron_ids</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">synapse_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">synaptic_weights_original</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">synaptic_weights</span> <span class="o">=</span> <span class="p">[]</span> 				
		<span class="bp">self</span><span class="o">.</span><span class="n">synaptic_delays</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">enable_stdp</span> <span class="o">=</span> <span class="p">[]</span>

		<span class="c1"># Input spikes (can have a value)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">input_spikes</span> <span class="o">=</span> <span class="p">{}</span>
		
		<span class="c1"># Spike trains (monitoring all neurons)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spike_train</span> <span class="o">=</span> <span class="p">[]</span>

		<span class="c1"># STDP Parameters</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">stdp</span> <span class="o">=</span> <span class="kc">False</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">stdp_time_steps</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">stdp_Apos</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">stdp_Aneg</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">stdp_positive_update</span> <span class="o">=</span> <span class="kc">False</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">stdp_negative_update</span> <span class="o">=</span> <span class="kc">False</span>

		<span class="c1"># Backend parameters</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">=</span> <span class="n">backend</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sparse</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">num_mpi_ranks</span> <span class="o">=</span> <span class="n">num_mpi_ranks</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">fifo_python</span> <span class="o">=</span> <span class="kc">None</span> 
		<span class="bp">self</span><span class="o">.</span><span class="n">fifo_c</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">current_directory</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">dtype_int</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span> <span class="o">=</span> <span class="kc">None</span>

		<span class="c1"># Simulation parameters accessible to user</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">num_spikes</span> <span class="o">=</span> <span class="mi">0</span>

		<span class="c1"># Simulation parameters not accissible to user</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_neuron_thresholds</span> <span class="o">=</span> <span class="kc">None</span> 
		<span class="bp">self</span><span class="o">.</span><span class="n">_neuron_leaks</span> <span class="o">=</span> <span class="kc">None</span> 
		<span class="bp">self</span><span class="o">.</span><span class="n">_neuron_reset_states</span> <span class="o">=</span> <span class="kc">None</span> 
		<span class="bp">self</span><span class="o">.</span><span class="n">_neuron_refractory_periods_original</span> <span class="o">=</span> <span class="kc">None</span> 
		<span class="bp">self</span><span class="o">.</span><span class="n">_neuron_refractory_periods</span> <span class="o">=</span> <span class="kc">None</span> 
		<span class="bp">self</span><span class="o">.</span><span class="n">_internal_states</span> <span class="o">=</span> <span class="kc">None</span> 
		<span class="bp">self</span><span class="o">.</span><span class="n">_spikes</span> <span class="o">=</span> <span class="kc">None</span> 
		<span class="bp">self</span><span class="o">.</span><span class="n">_weights</span> <span class="o">=</span> <span class="kc">None</span> 
		<span class="bp">self</span><span class="o">.</span><span class="n">_stdp_enabled_synapses</span> <span class="o">=</span> <span class="kc">None</span> 
		<span class="bp">self</span><span class="o">.</span><span class="n">_input_spikes</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_Asum</span> <span class="o">=</span> <span class="kc">None</span> 
		<span class="bp">self</span><span class="o">.</span><span class="n">_Aneg</span> <span class="o">=</span> <span class="kc">None</span>

		<span class="c1"># Run Frontier setup communication if backend is Frontier</span>
		<span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;frontier&quot;</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_setup_frontier_communication</span><span class="p">()</span>




	<span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot; Display the SNN class in a legible format</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="n">num_neurons_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Number of neurons: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="si">}</span><span class="s2">&quot;</span>
		<span class="n">num_synapses_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Number of synapses: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_synapses</span><span class="si">}</span><span class="s2">&quot;</span>
		
		<span class="c1"># Neurons </span>
		<span class="n">neuron_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>	<span class="s2">&quot;Neuron ID&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">)),</span>
									<span class="s2">&quot;Threshold&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_thresholds</span><span class="p">,</span> 
									<span class="s2">&quot;Leak&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_leaks</span><span class="p">,</span> 
									<span class="s2">&quot;Reset State&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_reset_states</span><span class="p">,</span>
									<span class="s2">&quot;Refractory Period&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_refractory_periods</span>
								<span class="p">})</span>

		<span class="c1"># Synapses</span>
		<span class="n">synapse_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>	<span class="s2">&quot;Synapse ID&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_synapses</span><span class="p">)),</span>
									<span class="s2">&quot;Pre Neuron ID&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_synaptic_neuron_ids</span><span class="p">,</span>
									<span class="s2">&quot;Post Neuron ID&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_synaptic_neuron_ids</span><span class="p">,</span>
									<span class="s2">&quot;Original Weight&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">synaptic_weights_original</span><span class="p">,</span>
									<span class="s2">&quot;Weight&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">synaptic_weights</span><span class="p">,</span>
									<span class="s2">&quot;Delay&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">synaptic_delays</span><span class="p">,</span>
									<span class="s2">&quot;STDP Enabled&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_stdp</span>
								 <span class="p">})</span>

		<span class="c1"># STDP</span>
		<span class="n">stdp_info</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;STDP Enabled: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stdp</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
					<span class="sa">f</span><span class="s2">&quot;STDP Time Steps: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stdp_time_steps</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
					<span class="sa">f</span><span class="s2">&quot;STDP Positive Update: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stdp_positive_update</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
					<span class="sa">f</span><span class="s2">&quot;STDP Negative Update: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stdp_negative_update</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
					<span class="sa">f</span><span class="s2">&quot;STDP A positive: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stdp_Apos</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
					<span class="sa">f</span><span class="s2">&quot;STDP A negative: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stdp_Aneg</span><span class="si">}</span><span class="s2">&quot;</span>

		<span class="c1"># Input Spikes</span>
		<span class="n">times</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">nids</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>

		<span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_spikes</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">nid</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_spikes</span><span class="p">[</span><span class="n">time</span><span class="p">][</span><span class="s2">&quot;nids&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_spikes</span><span class="p">[</span><span class="n">time</span><span class="p">][</span><span class="s2">&quot;values&quot;</span><span class="p">]):</span>
				<span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
				<span class="n">nids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>
				<span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

		<span class="n">input_spikes_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>	<span class="p">{</span> <span class="s2">&quot;Time&quot;</span><span class="p">:</span> <span class="n">times</span><span class="p">,</span>
										  <span class="s2">&quot;Neuron ID&quot;</span><span class="p">:</span> <span class="n">nids</span><span class="p">,</span>
										  <span class="s2">&quot;Value&quot;</span><span class="p">:</span> <span class="n">values</span>
										<span class="p">})</span>

		<span class="c1"># Spike train</span>
		<span class="n">spike_train</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
		<span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">spikes</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_train</span><span class="p">):</span>
			<span class="n">spike_train</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Time: </span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s2">, Spikes: </span><span class="si">{</span><span class="n">spikes</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
				

		<span class="k">return</span> 	<span class="n">num_neurons_str</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
				<span class="n">num_synapses_str</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> \
				<span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Neuron Info: </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
				<span class="n">neuron_df</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
				<span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Synapse Info: </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
				<span class="n">synapse_df</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
				<span class="s2">&quot;</span><span class="se">\n</span><span class="s2">STDP Info: </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
				<span class="n">stdp_info</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
				<span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Input Spikes: </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
				<span class="n">input_spikes_df</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
				<span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Spike Train: </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
				<span class="n">spike_train</span> <span class="o">+</span> \
				<span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Number of spikes: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_spikes</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>




<div class="viewcode-block" id="SNN.create_neuron">
<a class="viewcode-back" href="../superneuromat.html#superneuromat.SNN.create_neuron">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">create_neuron</span><span class="p">(</span>	
		<span class="bp">self</span><span class="p">,</span> 
		<span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> 
		<span class="n">leak</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> 
		<span class="n">reset_state</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> 
		<span class="n">refractory_period</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

<span class="w">		</span><span class="sd">&quot;&quot;&quot; Create a neuron</span>

<span class="sd">		Args:</span>
<span class="sd">			threshold (float): Neuron threshold; the neuron spikes if its internal state is strictly greater than the neuron threshold (default: 0.0)</span>
<span class="sd">			leak (float): Neuron leak; the amount by which by which the internal state of the neuron is pushed towards its reset state (default: np.inf)</span>
<span class="sd">			reset_state (float): Reset state of the neuron; the value assigned to the internal state of the neuron after spiking (default: 0.0)</span>
<span class="sd">			refractory_period (int): Refractory period of the neuron; the number of time steps for which the neuron remains in a dormant state after spiking</span>

<span class="sd">		Returns:</span>
<span class="sd">			Returns the neuron ID</span>

<span class="sd">		Raises: </span>
<span class="sd">			TypeError if:</span>
<span class="sd">				1. threshold is not an int or a float</span>
<span class="sd">				2. leak is not an int or a float</span>
<span class="sd">				3. reset_state is not an int or a float</span>
<span class="sd">				4. refractory_period is not an int</span>

<span class="sd">			ValueError if: </span>
<span class="sd">				1. leak is less than 0.0</span>
<span class="sd">				2. refractory_period is less than 0</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="c1"># Type errors</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;threshold must be int or float&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">leak</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;leak must be int or float&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reset_state</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;reset_state must be int or float&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">refractory_period</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;refractory_period must be int&quot;</span><span class="p">)</span>


		<span class="c1"># Value errors</span>
		<span class="k">if</span> <span class="n">leak</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leak must be grater than or equal to zero&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">refractory_period</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;refractory_period must be greater than or equal to zero&quot;</span><span class="p">)</span>


		<span class="c1"># Collect neuron parameters</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">neuron_thresholds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">neuron_leaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">leak</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">neuron_reset_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reset_state</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">neuron_refractory_periods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">refractory_period</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span> <span class="o">+=</span> <span class="mi">1</span>


		<span class="c1"># Return neuron ID </span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span> <span class="o">-</span> <span class="mi">1</span></div>





<div class="viewcode-block" id="SNN.create_synapse">
<a class="viewcode-back" href="../superneuromat.html#superneuromat.SNN.create_synapse">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">create_synapse</span><span class="p">(</span>	
		<span class="bp">self</span><span class="p">,</span> 
		<span class="n">pre_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> 
		<span class="n">post_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> 
		<span class="n">weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> 
		<span class="n">delay</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
		<span class="n">stdp_enabled</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

<span class="w">		</span><span class="sd">&quot;&quot;&quot; Creates a synapse in the SNN from a pre-synaptic neuron to a post-synaptic neuron with a given set of synaptic parameters (weight, delay and enable_stdp)</span>

<span class="sd">		Args:</span>
<span class="sd">			pre_id (int): ID of the pre-synaptic neuron</span>
<span class="sd">			post_id (int): ID of the post-synaptic neuron</span>
<span class="sd">			weight (float): Synaptic weight; weight is multiplied to the incoming spike (default: 1.0)</span>
<span class="sd">			delay (int): Synaptic delay; number of time steps by which the outgoing signal of the syanpse is delayed by (default: 1)</span>
<span class="sd">			enable_stdp (bool): Boolean value that denotes whether or not STDP learning is enabled on the synapse (default: False)</span>

<span class="sd">		Raises:</span>
<span class="sd">			TypeError if: </span>
<span class="sd">				1. pre_id is not an int</span>
<span class="sd">				2. post_id is not an int</span>
<span class="sd">				3. weight is not a float</span>
<span class="sd">				4. delay is not an int</span>
<span class="sd">				5. enable_stdp is not a bool</span>

<span class="sd">			ValueError if:</span>
<span class="sd">				1. pre_id is less than 0</span>
<span class="sd">				2. post_id is less than 0</span>
<span class="sd">				3. delay is less than or equal to 0</span>

<span class="sd">			RuntimeError if:</span>
<span class="sd">				1. A synapse with the same (pre_id, post_id) already exists</span>

<span class="sd">		&quot;&quot;&quot;</span> 

		<span class="c1"># Type errors</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pre_id</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;pre_id must be int&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">post_id</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;post_id must be int&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;weight must be a float&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;delay must be an integer&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stdp_enabled</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;enable_stdp must be a bool&quot;</span><span class="p">)</span>
		

		<span class="c1"># Value errors</span>
		<span class="k">if</span> <span class="n">pre_id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;pre_id must be greater than or equal to zero&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">post_id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;post_id must be greater than or equal to zero&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">delay</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;delay must be greater than or equal to 1&quot;</span><span class="p">)</span>


		<span class="c1"># Check for duplicate synapses</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pre_id</span><span class="p">,</span> <span class="n">post_id</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_indices</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Synapse from neuron </span><span class="si">{</span><span class="n">pre_id</span><span class="si">}</span><span class="s2"> to neuron </span><span class="si">{</span><span class="n">post_id</span><span class="si">}</span><span class="s2"> already created&quot;</span><span class="p">)</span>
		

		<span class="c1"># Add synapse index to the synapse_indices set</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">synapse_indices</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">pre_id</span><span class="p">,</span> <span class="n">post_id</span><span class="p">))</span>

		<span class="c1"># Collect synapse parameters</span>
		<span class="k">if</span> <span class="n">delay</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">pre_synaptic_neuron_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pre_id</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">post_synaptic_neuron_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">post_id</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">synaptic_weights_original</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">synaptic_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">synaptic_delays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">enable_stdp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stdp_enabled</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">num_synapses</span> <span class="o">+=</span> <span class="mi">1</span>

		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
				<span class="n">temp_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_neuron</span><span class="p">()</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">create_synapse</span><span class="p">(</span><span class="n">pre_id</span><span class="p">,</span> <span class="n">temp_id</span><span class="p">)</span>
				<span class="n">pre_id</span> <span class="o">=</span> <span class="n">temp_id</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">create_synapse</span><span class="p">(</span><span class="n">pre_id</span><span class="p">,</span> <span class="n">post_id</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">stdp_enabled</span><span class="o">=</span><span class="n">stdp_enabled</span><span class="p">)</span>


		<span class="c1"># Return synapse ID</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_synapses</span> <span class="o">-</span> <span class="mi">1</span></div>





<div class="viewcode-block" id="SNN.add_spike">
<a class="viewcode-back" href="../superneuromat.html#superneuromat.SNN.add_spike">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">add_spike</span><span class="p">(</span>	
		<span class="bp">self</span><span class="p">,</span> 
		<span class="n">time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> 
		<span class="n">neuron_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> 
		<span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot; Adds an external spike in the SNN </span>

<span class="sd">		Args:</span>
<span class="sd">			time (int): The time step at which the external spike is added</span>
<span class="sd">			neuron_id (int): The neuron for which the external spike is added</span>
<span class="sd">			value (float): The value of the external spike (default: 1.0)</span>

<span class="sd">		Raises:</span>
<span class="sd">			TypeError if:</span>
<span class="sd">				1. time is not an int</span>
<span class="sd">				2. neuron_id is not an int</span>
<span class="sd">				3. value is not an int or float</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="c1"># Type errors</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;time must be int&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">neuron_id</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;neuron_id must be int&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;value must be int or float&quot;</span><span class="p">)</span>


		<span class="c1"># Value errors</span>
		<span class="k">if</span> <span class="n">time</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;time must be greater than or equal to zero&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">neuron_id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;neuron_id must be greater than or equal to zero&quot;</span><span class="p">)</span>


		<span class="c1"># Add spikes</span>
		<span class="k">if</span> <span class="n">time</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_spikes</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">input_spikes</span><span class="p">[</span><span class="n">time</span><span class="p">][</span><span class="s2">&quot;nids&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neuron_id</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">input_spikes</span><span class="p">[</span><span class="n">time</span><span class="p">][</span><span class="s2">&quot;values&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
		
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">input_spikes</span><span class="p">[</span><span class="n">time</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">input_spikes</span><span class="p">[</span><span class="n">time</span><span class="p">][</span><span class="s2">&quot;nids&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">neuron_id</span><span class="p">]</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">input_spikes</span><span class="p">[</span><span class="n">time</span><span class="p">][</span><span class="s2">&quot;values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span></div>





<div class="viewcode-block" id="SNN.stdp_setup">
<a class="viewcode-back" href="../superneuromat.html#superneuromat.SNN.stdp_setup">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">stdp_setup</span><span class="p">(</span>	
		<span class="bp">self</span><span class="p">,</span> 
		<span class="n">time_steps</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> 
		<span class="n">Apos</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">],</span> 
		<span class="n">Aneg</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">],</span> 
		<span class="n">positive_update</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
		<span class="n">negative_update</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

<span class="w">		</span><span class="sd">&quot;&quot;&quot; Choose the appropriate STDP setup function based on backend</span>

<span class="sd">		Args:</span>
<span class="sd">			time_steps (int): Number of time steps over which STDP learning occurs (default: 3)</span>
<span class="sd">			Apos (list): List of parameters for excitatory STDP updates (default: [1.0, 0.5, 0.25]); number of elements in the list must be equal to time_steps</span>
<span class="sd">			Aneg (list): List of parameters for inhibitory STDP updates (default: [1.0, 0.5, 0.25]); number of elements in the list must be equal to time_steps</span>
<span class="sd">			positive_update (bool): Boolean parameter indicating whether excitatory STDP update should be enabled</span>
<span class="sd">			negative_update (bool): Boolean parameter indicating whether inhibitory STDP update should be enabled</span>

<span class="sd">		Raises: </span>
<span class="sd">			TypeError if:</span>
<span class="sd">				1. time_steps is not an int</span>
<span class="sd">				2. Apos is not a list</span>
<span class="sd">				3. Aneg is not a list</span>
<span class="sd">				4. positive_update is not a bool</span>
<span class="sd">				5. negative_update is not a bool</span>

<span class="sd">			ValueError if:</span>
<span class="sd">				1. time_steps is less than or equal to zero</span>
<span class="sd">				2. Number of elements in Apos is not equal to the time_steps</span>
<span class="sd">				3. Number of elements in Aneg is not equal to the time_steps</span>
<span class="sd">				4. The elements of Apos are not int or float</span>
<span class="sd">				5. The elements of Aneg are not int or float</span>
<span class="sd">				6. The elements of Apos are not greater than or equal to 0.0</span>
<span class="sd">				7. The elements of Apos are not greater than or equal to 0.0</span>

<span class="sd">			RuntimeError if: </span>
<span class="sd">				1. enable_stdp is not set to True on any of the synapses</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="c1"># Type errors</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_steps</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;time_steps should be int&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Apos</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Apos should be a list&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Aneg</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Aneg should be a list&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">positive_update</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;positive_update must be a bool&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">negative_update</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;negative_update must be a bool&quot;</span><span class="p">)</span>


		<span class="c1"># Value error</span>
		<span class="k">if</span> <span class="n">time_steps</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;time_steps should be greater than zero&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">positive_update</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">Apos</span><span class="p">)</span> <span class="o">!=</span> <span class="n">time_steps</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Length of Apos should be </span><span class="si">{</span><span class="n">time_steps</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">negative_update</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">Aneg</span><span class="p">)</span> <span class="o">!=</span> <span class="n">time_steps</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Length of Aneg should be </span><span class="si">{</span><span class="n">time_steps</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">positive_update</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Apos</span><span class="p">]):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All elements in Apos should be int or float&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">negative_update</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Aneg</span><span class="p">]):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All elements in Aneg should be int or float&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">positive_update</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Apos</span><span class="p">]):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All elements in Apos should be positive&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">negative_update</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Aneg</span><span class="p">]):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All elements in Aneg should be positive&quot;</span><span class="p">)</span>		

		
		<span class="c1"># Runtime error</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">enable_stdp</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;STDP is not enabled on any synapse, might want to skip stdp_setup()&quot;</span><span class="p">)</span>


		<span class="c1"># Set STDP flag</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">stdp</span> <span class="o">=</span> <span class="kc">True</span> 


		<span class="c1"># Choose the appropriate STDP setup function based on backend</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_stdp_setup_cpu</span><span class="p">(</span><span class="n">time_steps</span><span class="p">,</span> <span class="n">Apos</span><span class="p">,</span> <span class="n">Aneg</span><span class="p">,</span> <span class="n">positive_update</span><span class="p">,</span> <span class="n">negative_update</span><span class="p">)</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;frontier&quot;</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_stdp_setup_frontier</span><span class="p">()</span></div>





<div class="viewcode-block" id="SNN.setup">
<a class="viewcode-back" href="../superneuromat.html#superneuromat.SNN.setup">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="mi">64</span><span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot; Choose the appropriate setup function based on backend</span>
<span class="sd">		</span>
<span class="sd">		Args:</span>
<span class="sd">			sparse (bool): If True, forces simulation to use sparse computations (default: &quot;auto&quot;)</span>
<span class="sd">			dtype (int): 32 or 64 for single or double precision operation (default: 64)</span>

<span class="sd">		Raises:</span>
<span class="sd">			TypeError if:</span>
<span class="sd">				1. sparse is not a bool</span>
<span class="sd">				2. dtype is not an int</span>

<span class="sd">			ValueError if:</span>
<span class="sd">				1. dtype is not 32 or 64</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="c1"># Type errors</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sparse</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sparse</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">)):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;sparse must be True, False, or &#39;auto&#39;&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;dtype must be 32 or 64 for single or double precision&quot;</span><span class="p">)</span>


		<span class="c1"># Value errors</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dtype</span> <span class="o">!=</span> <span class="mi">32</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dtype</span> <span class="o">!=</span> <span class="mi">64</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span> <span class="p">(</span><span class="s2">&quot;dtype must be 32 or 64 for single or double precision&quot;</span><span class="p">)</span>
		
		<span class="c1"># Set self.sparse</span>
		<span class="k">if</span> <span class="n">sparse</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span> 
			<span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_synapses</span> <span class="o">&lt;</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="o">**</span><span class="mi">2</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">sparse</span> <span class="o">=</span> <span class="kc">True</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">sparse</span> <span class="o">=</span> <span class="kc">False</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">sparse</span> <span class="o">=</span> <span class="n">sparse</span>


		<span class="c1"># Set dtype</span>
		<span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="mi">32</span><span class="p">:</span> 
			<span class="bp">self</span><span class="o">.</span><span class="n">dtype_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>

		<span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="mi">64</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dtype_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span> 
			<span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span> 

		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown dtype </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


		<span class="c1"># Choose appropriate setup function based on the backend</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;cpu&quot;</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_setup_cpu</span><span class="p">()</span>

		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;frontier&quot;</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_setup_frontier</span><span class="p">()</span>

		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Backend </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="si">}</span><span class="s2"> not supported currently, only backends supported are &#39;cpu&#39; and &#39;frontier&#39;&quot;</span><span class="p">)</span></div>





<div class="viewcode-block" id="SNN.simulate">
<a class="viewcode-back" href="../superneuromat.html#superneuromat.SNN.simulate">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_steps</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot; Simulate the spiking neural network </span>

<span class="sd">		Args:</span>
<span class="sd">			time_steps (int): Number of time steps for which the SNN is to be simulated</span>
<span class="sd">			backend (string): Backend is either cpu or frontier</span>

<span class="sd">		Raises: </span>
<span class="sd">			TypeError if:</span>
<span class="sd">				1. time_steps is not an int</span>
<span class="sd">				2. backend is not a string</span>

<span class="sd">			ValueError if: </span>
<span class="sd">				1. time_steps is less than or equal to zero</span>
<span class="sd">				2. backend is not one of the following values: cpu, frontier</span>

<span class="sd">		&quot;&quot;&quot;</span> 

		<span class="c1"># Type errors</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_steps</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;time_steps must be int&quot;</span><span class="p">)</span>


		<span class="c1"># Value errors</span>
		<span class="k">if</span> <span class="n">time_steps</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;time_steps must be greater than zero&quot;</span><span class="p">)</span>


		<span class="c1"># Select appropriate simulation function</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;cpu&quot;</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_simulate_cpu</span><span class="p">(</span><span class="n">time_steps</span><span class="o">=</span><span class="n">time_steps</span><span class="p">)</span>

		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;frontier&quot;</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_simulate_frontier</span><span class="p">(</span><span class="n">time_steps</span><span class="o">=</span><span class="n">time_steps</span><span class="p">)</span>

		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unsupported backend:&quot;</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span></div>





<div class="viewcode-block" id="SNN.count_spikes">
<a class="viewcode-back" href="../superneuromat.html#superneuromat.SNN.count_spikes">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">count_spikes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot; Returns the spike count</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_spikes</span></div>





<div class="viewcode-block" id="SNN.reset">
<a class="viewcode-back" href="../superneuromat.html#superneuromat.SNN.reset">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
			<span class="n">internal_states</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
			<span class="n">refractory_periods</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
			<span class="n">internal_spikes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
			<span class="n">stdp_enabled_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
			<span class="n">spike_train</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
			<span class="n">spike_count</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
			<span class="n">input_spikes</span><span class="o">=</span><span class="kc">True</span>
		<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

<span class="w">		</span><span class="sd">&quot;&quot;&quot; Resets the state of the simulator</span>

<span class="sd">		Args:</span>
<span class="sd">			internal_states (bool): Set to True if internal states of neurons should be reset, otherwise False (default: True)</span>
<span class="sd">			refractory_periods (bool): Set to True if refractory periods of neurons should be reset, otherwise False (default: True)</span>
<span class="sd">			internal_spikes (bool): Set to True if internal spikes of neurons should be reset, otherwise False (default: True)</span>
<span class="sd">			stdp_enabled_weights (bool): Set to True if STDP enabled synaptic weights should be reset, otherwise False (default: True)</span>
<span class="sd">			spike_train (bool): Set to True if spike train should be reset, otherwise False (default: True)</span>
<span class="sd">			spike_count (bool): Set to True if spike count should be reset, otherwise False (default: True)</span>
<span class="sd">			input_spikes (bool): Set to True if input spikes should be reset, otherwise False (default: True)</span>

<span class="sd">		Raises:</span>
<span class="sd">			TypeError if:</span>
<span class="sd">				1. internal_states is not bool</span>
<span class="sd">				2. refractory_periods is not bool </span>
<span class="sd">				3. internal_spikes is not bool</span>
<span class="sd">				4. stdp_enabled_weights is not bool</span>
<span class="sd">				5. spike_train is not bool</span>
<span class="sd">				6. spike_count is not bool </span>
<span class="sd">				7. input_spikes is not bool</span>

<span class="sd">			Value error if: </span>
<span class="sd">				1. internal_states is neither True nor False</span>
<span class="sd">				2. refractory_periods is neither True nor False</span>
<span class="sd">				3. internal_spikes is neither True nor False</span>
<span class="sd">				4. stdp_enabled_weights is neither True nor False</span>
<span class="sd">				5. spike_train is neither True nor False</span>
<span class="sd">				6. spike_count is neither True nor False</span>
<span class="sd">				7. input_spikes is neither True nor False</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="c1"># TypeErrors</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">internal_states</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;internal_states must be bool&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">refractory_periods</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;refractory_periods must be bool&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">internal_spikes</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;internal_spikes must be bool&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stdp_enabled_weights</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;stdp_enabled_weights must be bool&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spike_train</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;spike_train must be bool&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spike_count</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;spike_count must be bool&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_spikes</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input_spikes must be bool&quot;</span><span class="p">)</span>


		<span class="c1"># ValueErrors</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">internal_states</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">internal_states</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;internal_states must be True or False&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">refractory_periods</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">refractory_periods</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;refractory_periods must be True or False&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">internal_spikes</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">internal_spikes</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;internal_spikes must be True or False&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">stdp_enabled_weights</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">stdp_enabled_weights</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;stdp_enabled_weights must be True or False&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">spike_train</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">spike_train</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;spike_train must be True or False&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">spike_count</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">spike_count</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;spike_count must be True or False&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">input_spikes</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">input_spikes</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input_spikes must be True or False&quot;</span><span class="p">)</span>


		<span class="c1"># Reset internal_states</span>
		<span class="k">if</span> <span class="n">internal_states</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_internal_states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_reset_states</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>

		<span class="c1"># Reset refractory periods</span>
		<span class="k">if</span> <span class="n">refractory_periods</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_refractory_periods</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>

		<span class="c1"># Reset internal spikes</span>
		<span class="k">if</span> <span class="n">internal_spikes</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>

		<span class="c1"># Reset STDP enabled weights</span>
		<span class="k">if</span> <span class="n">stdp_enabled_weights</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">synaptic_weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synaptic_weights_original</span><span class="p">]</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_weights</span> <span class="o">=</span> <span class="n">csc_array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">synaptic_weights</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pre_synaptic_neuron_ids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_synaptic_neuron_ids</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pre_synaptic_neuron_ids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_synaptic_neuron_ids</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">synaptic_weights</span>

		<span class="c1"># Reset spike train</span>
		<span class="k">if</span> <span class="n">spike_train</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">spike_train</span> <span class="o">=</span> <span class="p">[]</span>

		<span class="c1"># Reset spike count</span>
		<span class="k">if</span> <span class="n">spike_count</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">num_spikes</span> <span class="o">=</span> <span class="mi">0</span> 

		<span class="c1"># Reset input spikes </span>
		<span class="k">if</span> <span class="n">input_spikes</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_input_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span></div>





<div class="viewcode-block" id="SNN.print_spike_train">
<a class="viewcode-back" href="../superneuromat.html#superneuromat.SNN.print_spike_train">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">print_spike_train</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot; Prints the spike train</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">spike_train</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_train</span><span class="p">):</span>
			<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time: </span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s2">, Spikes: </span><span class="si">{</span><span class="n">spike_train</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

		<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Number of spikes: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_spikes</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>





	<span class="k">def</span><span class="w"> </span><span class="nf">_stdp_setup_cpu</span><span class="p">(</span>	
		<span class="bp">self</span><span class="p">,</span> 
		<span class="n">time_steps</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> 
		<span class="n">Apos</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">],</span> 
		<span class="n">Aneg</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">],</span> 
		<span class="n">positive_update</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
		<span class="n">negative_update</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

<span class="w">		</span><span class="sd">&quot;&quot;&quot; Setup the Spike-Time-Dependent Plasticity (STDP) parameters on CPU backend</span>

<span class="sd">		Args:</span>
<span class="sd">			time_steps (int): Number of time steps over which STDP learning occurs (default: 3)</span>
<span class="sd">			Apos (list): List of parameters for excitatory STDP updates (default: [1.0, 0.5, 0.25]); number of elements in the list must be equal to time_steps</span>
<span class="sd">			Aneg (list): List of parameters for inhibitory STDP updates (default: [1.0, 0.5, 0.25]); number of elements in the list must be equal to time_steps</span>
<span class="sd">			positive_update (bool): Boolean parameter indicating whether excitatory STDP update should be enabled</span>
<span class="sd">			negative_update (bool): Boolean parameter indicating whether inhibitory STDP update should be enabled</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="c1"># Collect STDP parameters</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">stdp_time_steps</span> <span class="o">=</span> <span class="n">time_steps</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">stdp_Apos</span> <span class="o">=</span> <span class="n">Apos</span> 
		<span class="bp">self</span><span class="o">.</span><span class="n">stdp_Aneg</span> <span class="o">=</span> <span class="n">Aneg</span> 
		<span class="bp">self</span><span class="o">.</span><span class="n">stdp_positive_update</span> <span class="o">=</span> <span class="n">positive_update</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">stdp_negative_update</span> <span class="o">=</span> <span class="n">negative_update</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stdp_positive_update</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">stdp_Apos</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">stdp_time_steps</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stdp_negative_update</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">stdp_Aneg</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">stdp_time_steps</span>




	<span class="k">def</span><span class="w"> </span><span class="nf">_setup_cpu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot; Setup the SNN for simulation on CPU backend</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="c1"># Create numpy arrays for neuron state variables</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_neuron_thresholds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_thresholds</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_neuron_leaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_leaks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_neuron_reset_states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_reset_states</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_neuron_refractory_periods_original</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_refractory_periods</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_neuron_refractory_periods</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_internal_states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_reset_states</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
		
		<span class="c1"># Create numpy arrays for synapse state variables</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_weights</span> <span class="o">=</span> <span class="n">csc_array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">synaptic_weights</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pre_synaptic_neuron_ids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_synaptic_neuron_ids</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pre_synaptic_neuron_ids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_synaptic_neuron_ids</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">synaptic_weights</span>

		<span class="c1"># Create numpy arrays for STDP state variables</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stdp</span><span class="p">:</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_stdp_enabled_synapses</span> <span class="o">=</span> <span class="n">csc_array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">enable_stdp</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pre_synaptic_neuron_ids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_synaptic_neuron_ids</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_stdp_enabled_synapses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_stdp_enabled_synapses</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pre_synaptic_neuron_ids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_synaptic_neuron_ids</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_stdp</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_Aneg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stdp_Aneg</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_Asum</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stdp_Apos</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Aneg</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>			

		<span class="c1"># Create numpy array for input spikes state variable</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_input_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>




	<span class="k">def</span><span class="w"> </span><span class="nf">_simulate_cpu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_steps</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot; Simulates the SNN on CPU backend</span>

<span class="sd">		Args:</span>
<span class="sd">			time_steps (int): Number of time steps for which the SNN is to be simulated</span>
<span class="sd">			backend (string): Backend is either cpu or frontier</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="c1"># Simulate</span>
		<span class="k">for</span> <span class="n">time_step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">time_steps</span><span class="p">):</span>
			<span class="c1"># print(f&quot;\n{time_step} Start: {self._internal_states}&quot;)</span>

			<span class="c1"># Leak: internal state &gt; reset state</span>
			<span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal_states</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neuron_reset_states</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_internal_states</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal_states</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neuron_leaks</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neuron_reset_states</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
			
			<span class="c1"># print(f&quot;{time_step} After positive leak: {type(self._weights[0,0])}, {type(self._weights)}, {self._weights}&quot;)</span>

			
			<span class="c1"># Leak: internal state &lt; reset state</span>
			<span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal_states</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neuron_reset_states</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_internal_states</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal_states</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neuron_leaks</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neuron_reset_states</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
			
			<span class="c1"># print(f&quot;{time_step} After negative leak: {type(self._weights[0,0])}, {type(self._weights)}, {self._weights}&quot;)</span>


			<span class="c1"># Zero out _input_spikes to prepare them for input spikes in current time step</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_input_spikes</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_spikes</span> 	


			<span class="c1"># Include input spikes for current time step</span>
			<span class="k">if</span> <span class="n">time_step</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_spikes</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_input_spikes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">input_spikes</span><span class="p">[</span><span class="n">time_step</span><span class="p">][</span><span class="s2">&quot;nids&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_spikes</span><span class="p">[</span><span class="n">time_step</span><span class="p">][</span><span class="s2">&quot;values&quot;</span><span class="p">]</span> 

			<span class="c1"># print(f&quot;{time_step} After input spikes: {type(self._weights[0,0])}, {type(self._weights)}, {self._weights}&quot;)</span>


			<span class="c1"># Internal state			</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_internal_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal_states</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_spikes</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spikes</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
			
			<span class="c1"># print(f&quot;{time_step} After internal state: {type(self._weights[0,0])}, {type(self._weights)}, {self._weights}&quot;)</span>


			<span class="c1"># Compute spikes</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal_states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neuron_thresholds</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_int</span><span class="p">)</span>
			
			<span class="c1"># print(f&quot;{time_step} After computing spikes: {type(self._weights[0,0])}, {type(self._weights)}, {self._weights}&quot;)</span>
			

			<span class="c1"># Refractory period: Compute indices of neuron which are in their refractory period</span>
			<span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_neuron_refractory_periods</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
			
			<span class="c1"># print(f&quot;{time_step} After refractory period: {type(self._weights[0,0])}, {type(self._weights)}, {self._weights}&quot;)</span>
			

			<span class="c1"># For neurons in their refractory period, zero out their spikes and decrement refractory period by one</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_spikes</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_neuron_refractory_periods</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

			<span class="c1"># print(f&quot;{time_step} After zeroing out spikes for neurons in refractory period: {type(self._weights[0,0])}, {type(self._weights)}, {self._weights}&quot;)</span>


			<span class="c1"># For spiking neurons, turn on refractory period</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spikes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_neuron_refractory_periods</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neuron_refractory_periods_original</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

			<span class="c1"># print(f&quot;{time_step} After turning on refractory period: {type(self._weights[0,0])}, {type(self._weights)}, {self._weights}&quot;)</span>

			
			<span class="c1"># Reset internal states</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_internal_states</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neuron_reset_states</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

			<span class="c1"># print(f&quot;{time_step} After resetting internal state: {type(self._weights[0,0])}, {type(self._weights)}, {self._weights}&quot;)</span>


			<span class="c1"># Update spike count</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">num_spikes</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spikes</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

			<span class="c1"># print(f&quot;{time_step} After counting spikes: {type(self._weights[0,0])}, {type(self._weights)}, {self._weights}&quot;)</span>


			<span class="c1"># Append spike train</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">spike_train</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spikes</span><span class="p">)</span>

			<span class="c1"># print(f&quot;{time_step} After spike train: {type(self._weights[0,0])}, {type(self._weights)}, {self._weights}&quot;)</span>


			<span class="c1"># STDP Operations</span>
			<span class="n">t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stdp_time_steps</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_train</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

			<span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stdp</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">:</span>
					<span class="n">Sprev</span> <span class="o">=</span> <span class="n">csc_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_train</span><span class="p">[</span><span class="o">-</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
					<span class="n">Scurr</span> <span class="o">=</span> <span class="n">csc_array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_train</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="n">t</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
					<span class="c1"># self._weights += ( ( ( (self._Asum[-t:] * Sprev).T @ Scurr) * self._stdp_enabled_synapses) - (self._Aneg[-t:].sum() * self._stdp_enabled_synapses) ).astype(self.dtype_float)</span>

				<span class="k">else</span><span class="p">:</span>
					<span class="n">Sprev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_train</span><span class="p">[</span><span class="o">-</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
					<span class="n">Scurr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_train</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="n">t</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
				
				<span class="bp">self</span><span class="o">.</span><span class="n">_weights</span> <span class="o">+=</span> <span class="p">((((</span><span class="bp">self</span><span class="o">.</span><span class="n">_Asum</span><span class="p">[</span><span class="o">-</span><span class="n">t</span><span class="p">:]</span> <span class="o">*</span> <span class="n">Sprev</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Scurr</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stdp_enabled_synapses</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Aneg</span><span class="p">[</span><span class="o">-</span><span class="n">t</span><span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stdp_enabled_synapses</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>


				<span class="c1"># else: </span>
				<span class="c1"># 	_update_synapses = np.outer(np.array(self.spike_train[-t-1:-1], dtype=self.dtype_float), np.array(self.spike_train[-1], dtype=self.dtype_float)).reshape([-1, self.num_neurons, self.num_neurons])</span>

				<span class="c1"># 	print(f&quot;{time_step} After computing update synapses: {type(_update_synapses[0,0,0])}, {type(_update_synapses)}, {_update_synapses}&quot;)</span>


				<span class="c1"># 	if self.stdp_positive_update:</span>
				<span class="c1"># 		self._weights += (((_update_synapses.T * self.stdp_Apos[0:t][::-1]).T).sum(axis=0) * self._stdp_enabled_synapses).astype(self.dtype_float)</span>

				<span class="c1"># 	print(f&quot;{time_step} After positive STDP: {type(self._weights[0,0])}, {type(self._weights)}, {self._weights}&quot;)</span>


				<span class="c1"># 	if self.stdp_negative_update:</span>
				<span class="c1"># 		self._weights -= ((((1 - _update_synapses).T * self.stdp_Aneg[0:t][::-1]).T).sum(axis=0) * self._stdp_enabled_synapses).astype(self.dtype_float)</span>
		
				<span class="c1"># 	print(f&quot;{time_step} After negative STDP: {type(self._weights[0,0])}, {type(self._weights)}, {self._weights}&quot;)</span>

		
		<span class="c1"># Update weights if STDP was enabled</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stdp</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">synaptic_weights</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pre_synaptic_neuron_ids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_synaptic_neuron_ids</span><span class="p">])</span>

		<span class="c1"># print(f&quot;{time_step} After updating orignial weights: {type(self._weights[0,0])}, {type(self._weights)}, {self._weights}&quot;)</span>




	<span class="k">def</span><span class="w"> </span><span class="nf">_setup_frontier_communication</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot; Setup the communication </span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="c1"># Current directory</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">current_directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>

		
		<span class="c1"># Define the FIFO path</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">fifo_python</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_directory</span> <span class="o">+</span> <span class="s2">&quot;/fifo_python&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">fifo_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_directory</span> <span class="o">+</span> <span class="s2">&quot;/fifo_c&quot;</span>

		
		<span class="c1"># Compile and run C program</span>
		<span class="n">compile_command</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;mpicc&quot;</span><span class="p">,</span> <span class="s2">&quot;-Wall&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_directory</span> <span class="o">+</span> <span class="s2">&quot;/frontier.c&quot;</span><span class="p">,</span> <span class="s2">&quot;-o&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_directory</span> <span class="o">+</span> <span class="s2">&quot;/frontier.o&quot;</span><span class="p">]</span>
		<span class="n">run_command</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;mpiexec&quot;</span><span class="p">,</span> <span class="s2">&quot;-np&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_mpi_ranks</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_directory</span> <span class="o">+</span> <span class="s2">&quot;/frontier.o&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fifo_python</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fifo_c</span><span class="p">]</span>

		<span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">compile_command</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[Python _setup_frontier_communication] frontier.c compiled&quot;</span><span class="p">)</span>

		<span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span><span class="n">run_command</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[Python _setup_frontier_communication] frontier.o execution started&quot;</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">()</span>




	<span class="k">def</span><span class="w"> </span><span class="nf">_stdp_setup_frontier</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

<span class="w">		</span><span class="sd">&quot;&quot;&quot; Setup the Spike-Time-Dependent Plasticity (STDP) parameters for Frontier backend</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[Python _stdp_setup_frontier] Entered the _stdp_setup_frontier function&quot;</span><span class="p">)</span>


		<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fifo_python</span><span class="p">):</span>
			<span class="n">os</span><span class="o">.</span><span class="n">mkfifo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fifo_python</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fifo_c</span><span class="p">):</span>
			<span class="n">os</span><span class="o">.</span><span class="n">mkfifo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fifo_c</span><span class="p">)</span>

		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[Python _stdp_setup_frontier] fifo_python and fifo_c created&quot;</span><span class="p">)</span>

		<span class="c1"># Send data over the pipe</span>
		<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fifo_python</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
			<span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stdp_time_steps</span><span class="p">))</span>
			<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[Python _stdp_setup_frontier] Wrote stdp_time_steps to fifo_python&quot;</span><span class="p">)</span>
			<span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stdp_Apos</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">))</span>
			<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[Python _stdp_setup_frontier] Wrote stdp_Apos to fifo_python&quot;</span><span class="p">)</span>
			<span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stdp_Aneg</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">))</span>
			<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[Python _stdp_setup_frontier] Wrote stdp_Aneg to fifo_python&quot;</span><span class="p">)</span>
			<span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stdp_positive_update</span><span class="p">))</span>
			<span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stdp_negative_update</span><span class="p">))</span>
			
			<span class="c1"># with open(self.fifo_c, &quot;rb&quot;) as fc:</span>
			<span class="c1"># 	data = fc.read()</span>

		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[Python _stdp_setup_frontier] STDP data sent&quot;</span><span class="p">)</span>


		<span class="c1"># Initialize the data</span>
		<span class="c1"># first_data = 1.0</span>
		<span class="c1"># first_data = [1.0, 2.0, 3.0, 4.0, 5.0]</span>
		
		<span class="c1"># Setup the C shared library</span>
		<span class="c1"># c_executable_path = os.path.dirname(os.path.abspath(__file__)) + &quot;/frontier.o&quot;</span>
		<span class="c1"># lib = ctypes.CDLL(lib_path)</span>

		<span class="c1"># Setup the ctypes datatypes</span>
		<span class="c1"># c_float_array_type = ctypes.c_float * time_steps</span>

		<span class="c1"># Setup the data</span>
		<span class="c1"># time_steps = ctypes.c_int(time_steps)</span>
		<span class="c1"># Apos = c_float_array_type(*Apos)</span>
		<span class="c1"># Aneg = c_float_array_type(*Aneg)</span>
		<span class="c1"># positive_update = ctypes.c_int(positive_update)</span>
		<span class="c1"># negative_update = ctypes.c_int(negative_update)</span>

		<span class="c1"># Setup the C function</span>
		<span class="c1"># c_stdp_setup_frontier = c_lib.stdp_setup_frontier</span>
		<span class="c1"># c_stdp_setup_frontier.argtypes = [ctypes.c_int, c_float_array_type, c_float_array_type, ctypes.c_bool, ctypes.c_bool]</span>
		<span class="c1"># c_stdp_setup_frontier.restype = ctypes.c_int</span>

		<span class="c1"># lib.stdp_setup_frontier.argtypes = [ctypes.c_int, c_float_array_type, c_float_array_type, ctypes.c_bool, ctypes.c_bool]</span>
		<span class="c1"># lib.stdp_setup_frontier.restype = ctypes.c_int</span>

		<span class="c1"># Call the function</span>
		<span class="c1"># val = lib.stdp_setup_frontier(time_steps, Apos, Aneg, positive_update, negative_update)</span>

		<span class="c1"># Call the function</span>
		<span class="c1"># c_lib.stdp_setup_frontier(ctypes.c_float_p(first_data))</span>

		<span class="c1"># print(f&quot;[Python _stdp_setup_frontier] Function returned with value {val}&quot;)</span>


		<span class="c1"># Shared memory will contain: </span>
		<span class="c1"># 5 neuron properties: number of neurons, thresholds, leaks, reset states, and refractory periods, </span>
		<span class="c1"># 4 synapse properties: weights, delays, and stdp enabled, and</span>
		<span class="c1"># 5 STDP properties: STDP time steps, Apos, Aneg, positive update, and negative update</span>
		<span class="c1"># shared_memory_size = 0</span>
		<span class="c1"># shared_memory_size += size(np.int32) + size(self.dtype) * self.num_neurons * 4</span>
		<span class="c1"># shared_memory_size += size(np.int32) + size(self.dtype) * self.num_synapses * 3 </span>
		<span class="c1"># shared_memory_size += size(np.int32) * 3 + size(self.dtype) * self.stdp_time_steps * 2</span>


		<span class="c1"># process = subprocess.Popen(current_directory + &quot;reader&quot;, stdin=subprocess.PIPE, text=True)</span>
		<span class="c1"># process.communicate()</span>




	<span class="k">def</span><span class="w"> </span><span class="nf">_setup_frontier</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot; Setup the SNN for simulation on Frontier backend</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[Python _setup_frontier] Entered the _setup_frontier function&quot;</span><span class="p">)</span>


		<span class="c1"># Make fifos</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fifo_python</span><span class="p">):</span>
			<span class="n">os</span><span class="o">.</span><span class="n">mkfifo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fifo_python</span><span class="p">)</span>

		<span class="c1"># if not os.path.exists(self.fifo_c):</span>
		<span class="c1"># 	os.mkfifo(self.fifo_c)</span>

		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[Python _setup_frontier] fifo_python created&quot;</span><span class="p">)</span>


		<span class="c1"># Send neuron and synapse data over the pipe</span>
		<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fifo_python</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
			<span class="c1"># Neuron parameters: num_neurons, neuron_thresholds, neuron_leaks, neuron_reset_states, and neuron_refractory_periods</span>
			<span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">))</span>
			<span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_thresholds</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">))</span>
			<span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_leaks</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">))</span>
			<span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_reset_states</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">))</span>
			<span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_refractory_periods</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_int</span><span class="p">))</span>

			<span class="c1"># Synapse parameters: num_synapses, pre_synaptic_neuron_ids, post_synaptic_neuron_ids, synaptic_weights, stdp_enabled</span>
			<span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_synapses</span><span class="p">))</span>
			<span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pre_synaptic_neuron_ids</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_int</span><span class="p">))</span>
			<span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">post_synaptic_neuron_ids</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_int</span><span class="p">))</span>
			<span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">synaptic_weights</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">))</span>
			<span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">enable_stdp</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_int</span><span class="p">))</span>


		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[Python _setup_frontier] Neuron and synapse data sent&quot;</span><span class="p">)</span>

		<span class="c1"># with open(self.fifo_c, &quot;rb&quot;) as fc:</span>
		<span class="c1"># 	data = fc.readline()</span>
		<span class="c1"># 	print(f&quot;Data received from C: {str(data)}&quot;)</span>




		<span class="c1"># Initialize the data</span>
		<span class="c1"># second_data = 5.0</span>
		<span class="c1"># second_data = [6.0, 7.0, 8.0, 9.0, 10.0]</span>

		<span class="c1"># # Setup the C shared library</span>
		<span class="c1"># c_lib_path = os.path.dirname(os.path.abspath(__file__)) + &quot;/frontier.so&quot;</span>
		<span class="c1"># c_lib = ctypes.CDLL(c_lib_path)</span>

		<span class="c1"># # Setup the function</span>
		<span class="c1"># c_setup_frontier = c_lib.setup_frontier</span>
		<span class="c1"># c_setup_frontier.argtypes = [ctypes.c_float]</span>
		<span class="c1"># c_setup_frontier.restype = ctypes.c_int</span>


		<span class="c1"># Setup the C shared library</span>
		<span class="c1"># lib_path = os.path.dirname(os.path.abspath(__file__)) + &quot;/frontier.o&quot;</span>
		<span class="c1"># lib = ctypes.CDLL(lib_path)</span>

		<span class="c1"># # Setup the ctypes datatypes and data</span>
		<span class="c1"># c_float_array_type = ctypes.c_float * len(second_data)</span>

		<span class="c1"># # Setup the C function</span>
		<span class="c1"># c_setup_frontier = lib.setup_frontier</span>
		<span class="c1"># c_setup_frontier.argtypes = [ctypes.c_int, c_float_array_type]</span>
		<span class="c1"># c_setup_frontier.restype = ctypes.c_int</span>

		<span class="c1"># Call the functions</span>
		<span class="c1"># lib.initialize_mpi();</span>
		<span class="c1"># val = c_setup_frontier(len(second_data), c_float_array_type(*second_data))</span>

		<span class="c1"># num_processes = 4</span>
		
		<span class="c1"># print(f&quot;[Python _setup_frontier] Function returned with value {result}&quot;)</span>
	



	<span class="k">def</span><span class="w"> </span><span class="nf">_simulate_frontier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_steps</span><span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot; Simulates the SNN on the Frontier supercomputer</span>
<span class="sd">		</span>
<span class="sd">		Args:</span>
<span class="sd">			time_steps (int): Number of time steps for which the SNN is to be simulated</span>
<span class="sd">			backend (string): Backend is either cpu or frontier</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[Python _simulate_frontier] Entered the _simulate_frontier function&quot;</span><span class="p">)</span></div>


		<span class="c1"># Setup the C shared library</span>
		<span class="c1"># c_lib_path = os.path.dirname(os.path.abspath(__file__)) + &quot;/frontier.so&quot;</span>
		<span class="c1"># c_lib = ctypes.CDLL(c_lib_path)</span>

		<span class="c1"># Setup the ctypes datatypes and data</span>
		<span class="c1"># c_float_pointer_type = ctypes.POINTER(ctypes.c_float)</span>

		<span class="c1"># Setup the function</span>
		<span class="c1"># c_simulate_frontier = c_lib.simulate_frontier</span>
		<span class="c1"># c_simulate_frontier.argtypes = []</span>
		<span class="c1"># c_simulate_frontier.restype = c_float_pointer_type</span>

		<span class="c1"># Call the function</span>
		<span class="c1"># val = c_simulate_frontier()</span>
		<span class="c1"># val = np.frombuffer(val, dtype=np.float32)</span>

		<span class="c1"># if val:</span>
		<span class="c1"># 	val = [val[i] for i in range(5)]</span>
		<span class="c1"># 	print(f&quot;[Python _simulate_frontier] Function returned {val}&quot;)</span>
		<span class="c1"># else:</span>
		<span class="c1"># 	print(&quot;Function did not return anything good&quot;)</span>





	

			



</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Prasanna Date, Chathika Gunaratne, Shruti Kulkarni, Mark Coletti, Robert Patton, Thomas Potok.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>